#include <iostream>
using namespace std;


/*
    Here to clarify the problem setting: we are given the parameters of rectangles
    in a picture which contains robots. One robot have two armors, which are the
    rectangles captured by the camera. However, sometimes the camera cannot capture both
    two of the armors. Thus the rectangles either appear in pairs or alone. And it is
    possible for a rectangle to appear only once since its counterpart is not inside the
    picture.
    Our goal is to find the closet paired rectangle. By closest we mean the distance between
    the camera and the armor.

    We will store the input data in the fist array. Then we need to find out those in pair
    and store them in another list. Then we use compute the distance.

    The rectangle in pair will have the same y value. Later when refining the program
    we may need to consider the case where different pairs having the same y.
*/

/**
    Should be noted that so far, our criteria for judging whether two rectangles are the same is based
    on checking the y coordinate. However, strictly speaking, the width and height should also be checked.
    More revision might be necessary.
*/

int printrList5(int l[][5], int s){

    for (int r=0; r<s; r++){
        cout<<(r+1)<<": ";
        for (int c=0; c<5; c++){
            cout<<l[r][c];
            cout<<" | ";
        }
        cout<<endl;
    }
    return 0;
}

int printrList4(int l[][4], int s){

    for (int r=0; r<s; r++){
        cout<<(r+1)<<": ";
        for (int c=0; c<4; c++){
            cout<<l[r][c];
            cout<<" | ";
        }
        cout<<endl;
    }
    return 0;
}

int readNumRectData(){
    cout<<"Enter number of data you want to enter!"<<endl;
    int n=0;
    while(true){
        cin>>n;
        if (n<2){
            cout<<"Please enter at least two rectangles! Re-enter: ";
        }else{
            return n;
        }
    }

}


int readRects(int l[][5], int n){
    /*
    n is the number of columns. We will have an extra column to store whether
    this rectangle has been checked or not. Its initial value will be 0 and after
    being checked it will be set to 1.
    */
    cout<<"Enter rect data!"<<endl;
    for (int r=0; r<n; r++){
        for (int c=0; c<4; c++){
            cin>>l[r][c];
        }
        l[r][4]=0;
    }
    return 0;
}

/*
    This function takes the starting index and return the index of the counterpart, if
    there is any. If there is  no pair, -1 will be returned.
    */
int searchPair(int i, int rects1[][5], int nRow){

    int y=rects1[i][1];
    for (int j=i+1;j<nRow; j++ ){
        if (rects1[j][4]==0 && rects1[j][1]==y){

            rects1[j][4]=1;//easy to forget
            return j;
        }
    }
    return (-1);
}

int zeroRow(int r, int list[][5]){
    for (int i=0; i<4;i++){
        list[r][i]=0;
    }
}
int sortrList1(int rList1[][5], int nRow){
    /*
    This function will zero the single rectangles in rList1 and return the
    actual size of rList1 after cleaning.

    We will copy those paired rectangles to another rList2 in another function. The
    reason behind is that we want to get the actual size of rList1 first so that
    when can create a rList2 with all entries occupied, instead of a rList2 with empty
    entries since it will be difficult to manage.
    */
    for (int i=0; i<nRow; i++){

        if (rList1[i][4]==0){//if this rectangle has not been checked before
            rList1[i][4]=1;//easy to forget

            int index=searchPair(i, rList1, nRow);

            if (index==-1){
                //if the rectangle is single, we make all its entires to be 0, except for the last cell.
                zeroRow(i, rList1);
            }
        }
    }
    return 0;
}
int nonzeroRowNum(int rList1[][5], int nRow){
    int counter=nRow;
    for (int i=0; i<nRow; i++){

        if (rList1[i][0]==0 && rList1[i][1]==0 &&
            rList1[i][2]==0 && rList1[i][3]==0 && rList1[i][4]==1){
                //if this is a zeroed row
                counter--;
            }
    }
    return counter;
}

int updaterList2(int r1, int r2, int rList2[][4], int &m, int rList1[][5]){

    for (int j=0; j<4; j++){
        rList2[m][j]=rList1[r1][j];
    }
    m++;
    for (int j=0; j<4; j++){
        rList2[m][j]=rList1[r2][j];
    }
    m++;

}
int getrList2(int rList1[][5], int rList2[][4], int r1, int r2){
    /*
    This function transfers zeroed rList1 into rList2 with paired rectangle
    placed together. r1 is the # of rows in rList1 and r2 is the # of rows in rList2.
    */

    int m=0; //this m is used for update rList2

    for (int i=0; i<r1; i++){
        rList1[i][4]=0;
    }

    for (int i=0; i<r1; i++){
        int index=searchPair(i, rList1, r1);
        /*here you will encounter a problem. Since in previous searchPair you have
        already set all checked rows' [4] to be 1. This time no matching row will be found.
        index will always be equal to -1. So we may firstly set all the 1 to 0 again beforehand.
        */
        if(index!=-1){
            updaterList2(i, index, rList2, m, rList1);
        }
    }

    return 0;
}
int main()
{
    int numRectData=readNumRectData();
    int rList1[numRectData][5]={0};//rList1 will store input.

    readRects(rList1, numRectData);

    sortrList1(rList1, numRectData);
    cout<<"single rList1 row zeroed!"<<endl;
    printrList5(rList1, numRectData);



    int nzr=nonzeroRowNum(rList1, numRectData);
    int rList2[nzr][4]={0};
    getrList2(rList1, rList2, numRectData, nzr);
    cout<<"updated rList2!"<<endl;
    printrList4(rList2,nzr);

    int distance[nzr/2]={0};
    getDistance();
    getPair();


    return 0;
}

